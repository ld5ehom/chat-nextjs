# [ORM(Object Relational Mapping) 이란?](https://github.com/ld5ehom/chat-nextjs/commit/608a0a7acdfbff7c604876c921bbdcdb45cc4251)

객체와 관계형 데이터베이스의 데이터를 자동으로 변형 및 맵핑하는 작업입니다.
ORM을 이용한 개발은 객체와 데이터베이스의 변형에 유연하게 사용할 수 있습니다.

---

## 예시 개념 구조

객체(Object) ←→ 매핑 ←→ 관계형 DataBase

- 객체지향 프로그래밍은 클래스 사용
- 관계형 데이터베이스는 테이블 사용

- 객체 모델과 관계형 모델 간 불일치 존재...

---

## ORM vs Pure Javascript

- orm을 사용해서 board 테이블에서 데이터 가져오는 방법과 orm 사용하지 않고 가져오는 방법 비교

### orm

```
const boards = Board.find({ title: 'Hello', status: 'PUBLIC' });
```

### pure javascript

```
db.query('SELECT \* FROM boards WHERE title = "Hello" AND status = "PUBLIC"', (err, result) => {
    if (err) {
        throw new Error('Error')
    }

    boards = result.rows;
})
```

---

## ORM과 Node.js 추상화 계층

개발에서 추상화라는 것은 추상화를 많이 하면 할수록 어떠한 복잡한 로직을 알지 못하더라도 그 로직을 간단하게 사용할 수 있게 해 줍니다.  
(불필요한 정보는 숨기고 중요한 정보만을 표현해서 프로그램을 간단하게 해줍니다.)

예를 들어서, 커피를 마시기 위해서 커피머신을 이용할 줄 알면 커피 머신이 어떻게 작동하는지 몰라도 커피를 마실 수 있는 것과 같습니다.

데이터베이스도 사용하는 방법에 따라 추상화가 많이 되어있는 라이브러리를 사용할 수도 있고 그렇지 않은 라이브러리를 사용해서 데이터베이스를 컨트롤 할 수도 있습니다.  
그래서 추상화 정도를 3단계로 나눠서 살펴보겠습니다.

---

## 저수준: 데이터베이스 드라이버

참조: https://blog.logrocket.com/node-js-orms-why-shouldnt-use/

데이터베이스 드라이버는 데이터베이스 연결 (때때로 연결 풀링)을 처리합니다.  
이 수준에서는 원시 SQL 문자열을 작성하여 데이터베이스에 전달하고 데이터베이스에서 응답을 받습니다.  
Node.js 생태계에는 이 계층에서 작동하는 많은 라이브러리가 있습니다.

다음은 세 가지 인기 있는 라이브러리입니다.

- mysql: MySQL (mysql을 위한 데이터베이스 드라이버)
- pg: PostgreSQL (postgres를 위한 데이터베이스 드라이버)
- sqlite3: SQLite (sqlite를 위한 데이터베이스 드라이버)

이러한 각 라이브러리는 기본적으로 동일한 방식으로 작동합니다.  
데이터베이스 인증 정보를 가져오고,새 데이터베이스 인스턴스를 인스턴스화하고,데이터베이스에 연결하고, 문자열 형식으로 쿼리를 보내고 결과를 비동기적으로 처리합니다.

이러한 각 라이브러리는 기본적으로 동일한 방식으로 작동합니다. 데이터베이스 인증 정보를 가져오고, 새 데이터베이스 인스턴스를 인스턴스화하고, 데이터베이스에 연결하고, 문자열 형식으로 쿼리를 보내고 결과를 비동기적으로 처리합니다.

- 아래는 pg 모듈을 사용하여 치킨을 요리하는 데 필요한 재료 목록을 얻는 간단한 예입니다.

```
// npm install pg

const { Client } = require('pg');
const connection = require('./connection.json');
const client = new Client(connection);

client.connect();

const query = 'SELECT
  ingredient.*,
  item.name AS item_name,
  item.type AS item_type
FROM
  ingredient
LEFT JOIN
  item ON item.id = ingredient.item_id
WHERE
  ingredient.dish_id = $1;';

client
  .query(query, [1])
  .then(res => {
    console.log('Ingredients:');
    for (let row of res.rows) {
      console.log(`${row.item_name}: ${row.quantity} ${row.unit}`);
    }

    client.end();
  });

```

---

## 중간수준: 쿼리 빌더

이것은 단순한 데이터베이스 드라이버 모듈과 완전한 ORM을 사용하는 것의 중간 수준입니다. 이 계층에서 작동하는 가장 주목할만한 모듈은 Knex입니다.

이 모듈은 몇 가지 다른 SQL 언어에 대한 쿼리를 생성할 수 있습니다. 이 모듈은 앞서 언급한 라이브러리 중 하나에 의존합니다. — Knex와 함께 사용하려는 특정 라이브러리를 설치해야 합니다.

- knex: Query Builder

여기서 작성하는 쿼리는 기본 SQL 쿼리와 매우 유사합니다.
또한 한 가지 좋은 점은 문자열을 연결하여 SQL을 형성하는 경우(종종 보안 취약점이 발생함)보다 훨씬 더 편리한 방식으로 프로그래밍 방식으로 동적 쿼리를 생성할 수 있다는 것입니다.

- knex 모듈을 사용하여 치킨 티카 마살라를 요리하는 데 필요한 재료 목록을 얻는 간단한 예입니다.

```
// $ npm install pg knex

const knex = require('knex');
const connection = require('./connection.json');
const client = knex({
  client: 'pg',
  connection
});

client
  .select([
    '*',
    client.ref('item.name').as('item_name'),
    client.ref('item.type').as('item_type'),
  ])
  .from('ingredient')
  .leftJoin('item', 'item.id', 'ingredient.item_id')
  .where('dish_id', '=', 1)
  .debug()
  .then(rows => {
    console.log('Ingredients:');
    for (let row of rows) {
      console.log(`${row.item_name}: ${row.quantity} ${row.unit}`);
    }

    client.destroy();
  });
```

기본 SQL 쿼리와 비슷하지만 위에 문자열을 사용하는 것과 차이가 있습니다.

---

## 고수준: ORM

최고 수준의 추상화입니다. ORM으로 작업할 때 일반적으로 더 많은 설정을 사전에 수행해야 합니다.
ORM의 요점은 이름(object relational mapping)에서 알 수 있듯이 관계형 데이터베이스의 데이터를 애플리케이션의 객체(클래스 인스턴스)에 매핑하는 것입니다.

- typeorm
- sequelize
- prisma

---

## ORM 사용의 단점

- SQL이 아닌 ORM 자체를 배우게 됩니다. (각각 특정 ORM 자체를 배우는 시간도 오래걸리며 ORM 들 마다 다른 문법을 사용하는 곳도 많습니다.)
- ORM을 이용해서 복잡한 호출을 하면 성능이 좋지 않을 수 있습니다.
- Explain을 이용한 비용 측정

```
// database driver query (34)

SELECT
  ingredient.*,
  item.name AS item_name,
  item.type AS item_type
FROM
  ingredient
LEFT JOIN
  item ON item.id = ingredient.item_id
WHERE
  ingredient.dish_id = ?;
```

```
// knex query builder query (34)

select
  *,
  "item"."name" as "item_name",
  "item"."type" as "item_type"
from
  "ingredient"
left join
  "item" on "item"."id" = "ingredient"."item_id"
where
  "dish_id" = ?;

```

```
// query generated by orm (42: 더 오래걸림)

SELECT
  "dish"."id", "dish"."name", "dish"."veg", "items"."id" AS "items.id",
  "items"."name" AS "items.name", "items"."type" AS "items.type",
  "items->ingredient"."dish_id" AS "items.ingredient.dish_id",
  "items->ingredient"."item_id" AS "items.ingredient.item_id",
  "items->ingredient"."quantity" AS "items.ingredient.quantity",
  "items->ingredient"."unit" AS "items.ingredient.unit"
FROM
  "dish" AS "dish"
LEFT OUTER JOIN (
  "ingredient" AS "items->ingredient"
  INNER JOIN
    "item" AS "items" ON "items"."id" = "items->ingredient"."item_id"
) ON "dish"."id" = "items->ingredient"."dish_id"
WHERE
  "dish"."id" = ?;
```

---

## ORM 사용의 장점

- 하나의 소스 코드를 이용해서 여러 데이터베이스로 쉽게 교체 가능합니다.
- 중복 코드 방지
- SQL 인젝션 취약점으로부터 보호
- 모델 유효성 검사 지원
- TypeScript 지원

---

## ORM 환경에서 Raw SQL을 사용하는 경우

실무에서는 ORM을 사용하더라도 모든 쿼리를 ORM으로만 작성하지는 않습니다.
다음과 같은 경우에는 ORM 내부에서 Raw SQL을 병행하기도 합니다.

- 복잡한 집계 쿼리
- 성능이 중요한 리포트성 쿼리
- ORM으로 표현하기 어려운 데이터베이스 전용 기능 사용 시
- 기존에 이미 최적화된 SQL을 그대로 사용해야 하는 경우

대부분의 ORM은 이러한 사용을 위해 Raw Query 기능을 함께 제공합니다.

---

## ORM 사용 시 주의할 점: N+1 문제

ORM을 사용할 때 연관 관계를 잘못 설계하거나 조회 전략을 잘못 선택하면
N+1 쿼리 문제가 발생할 수 있습니다.

이는 하나의 쿼리를 기대했지만 실제로는
N개의 추가 쿼리가 실행되는 문제로, 성능 저하의 주요 원인이 됩니다.

따라서 ORM을 사용할 때는

- eager / lazy loading 전략
- join 기반 조회
- 실제 실행되는 SQL 확인
  이 중요합니다.

---

## 정리

ORM은 개발 생산성과 유지보수를 크게 향상시키는 도구이지만, 모든 상황에 적합한 만능 해결책은 아닙니다.
데이터 접근 계층의 추상화 수준을 이해하고, 상황에 따라 데이터베이스 드라이버, 쿼리 빌더, ORM을 적절히 선택하거나 혼용하는 것이 중요합니다.
